
 //[I-S]LN=1;[I-E]
// Useful imports //[I-S]LN=2;[I-E]
import java.util.*; //[I-S]LN=3;[I-E]
 //[I-S]LN=4;[I-E]
/** @Author Lucas Leandro (ITsMagic Founder) */ //[I-S]LN=5;[I-E]
class FPPlayerCB extends Component implements IFPPlayer { //[I-S]LN=6;[I-E]
 //[I-S]LN=7;[I-E]
  @Override //[I-S]LN=8;[I-E]
  public String getComponentMenu() { //[I-S]LN=9;[I-E]
    return "AFPP"; //[I-S]LN=10;[I-E]
  } //[I-S]LN=11;[I-E]
 //[I-S]LN=12;[I-E]
  @Order(idx = {-8}) //[I-S]LN=13;[I-E]
  public float walkSpeed = 2; //[I-S]LN=14;[I-E]
 //[I-S]LN=15;[I-E]
  @Order(idx = {-7}) //[I-S]LN=16;[I-E]
  public float runSpeed = 4; //[I-S]LN=17;[I-E]
 //[I-S]LN=18;[I-E]
  @Order(idx = {-6}) //[I-S]LN=19;[I-E]
  public float moveLerpSpeed = 2; //[I-S]LN=20;[I-E]
 //[I-S]LN=21;[I-E]
  @Order(idx = {-5}) //[I-S]LN=22;[I-E]
  public float jumpSpeed = 5; //[I-S]LN=23;[I-E]
 //[I-S]LN=24;[I-E]
  @Order(idx = {-4}) //[I-S]LN=25;[I-E]
  public float horizontalSensitivity = 10f; //[I-S]LN=26;[I-E]
 //[I-S]LN=27;[I-E]
  @Order(idx = {-3}) //[I-S]LN=28;[I-E]
  public float verticalSensitivity = 6f; //[I-S]LN=29;[I-E]
 //[I-S]LN=30;[I-E]
  @Order(idx = {-2}) //[I-S]LN=31;[I-E]
  public float cameraMinAngle = -89; //[I-S]LN=32;[I-E]
 //[I-S]LN=33;[I-E]
  @Order(idx = {-1}) //[I-S]LN=34;[I-E]
  public float cameraMaxAngle = 89; //[I-S]LN=35;[I-E]
 //[I-S]LN=36;[I-E]
  private Characterbody cb; //[I-S]LN=37;[I-E]
  private AFPPCamera ac; //[I-S]LN=38;[I-E]
  private IFPController ct; //[I-S]LN=39;[I-E]
  private IFPStepsEmitter se; //[I-S]LN=40;[I-E]
  private float appliedSpeed = 0; //[I-S]LN=41;[I-E]
  private Vector2 zero = new Vector2(); //[I-S]LN=42;[I-E]
  private boolean walking; //[I-S]LN=43;[I-E]
  private Vector2 walkVector = new Vector2(); //[I-S]LN=44;[I-E]
  private Set<Component> waterTriggers = new HashSet(); //[I-S]LN=45;[I-E]
 //[I-S]LN=46;[I-E]
  /// Run only once //[I-S]LN=47;[I-E]
  @Override //[I-S]LN=48;[I-E]
  public void start() {} //[I-S]LN=49;[I-E]
 //[I-S]LN=50;[I-E]
  /// Repeat every frame //[I-S]LN=51;[I-E]
  @Override //[I-S]LN=52;[I-E]
  public void repeat() { //[I-S]LN=53;[I-E]
    getCT(); //[I-S]LN=54;[I-E]
    if (ct == null) { //[I-S]LN=55;[I-E]
      Terminal.log("AFPP Needs a IFPController component..."); //[I-S]LN=56;[I-E]
      return; //[I-S]LN=57;[I-E]
    } //[I-S]LN=58;[I-E]
    getCB(); //[I-S]LN=59;[I-E]
    getSE(); //[I-S]LN=60;[I-E]
 //[I-S]LN=61;[I-E]
    move(); //[I-S]LN=62;[I-E]
    rotate(); //[I-S]LN=63;[I-E]
    emitSteps(); //[I-S]LN=64;[I-E]
  } //[I-S]LN=65;[I-E]
 //[I-S]LN=66;[I-E]
  private void move() { //[I-S]LN=67;[I-E]
    Vector2 joy = ct.getWalkDir(); //[I-S]LN=68;[I-E]
    if (joy == null) joy = zero; //[I-S]LN=69;[I-E]
    float speed = (ct.wantRun()) ? runSpeed : walkSpeed; //[I-S]LN=70;[I-E]
    appliedSpeed = Math.lerpInSeconds(appliedSpeed, speed, moveLerpSpeed * 50f); //[I-S]LN=71;[I-E]
    cb.setForwardSpeed(appliedSpeed * joy.y); //[I-S]LN=72;[I-E]
    cb.setSideSpeed(appliedSpeed * -joy.x); //[I-S]LN=73;[I-E]
    cb.setJumpSpeed(jumpSpeed); //[I-S]LN=74;[I-E]
 //[I-S]LN=75;[I-E]
    walking = (joy.x != 0 || joy.y != 0); //[I-S]LN=76;[I-E]
    walkVector.set(joy); //[I-S]LN=77;[I-E]
    walkVector.mulLocal(appliedSpeed); //[I-S]LN=78;[I-E]
 //[I-S]LN=79;[I-E]
    if (ct.wantJump()) { //[I-S]LN=80;[I-E]
      if (cb.canJump()) { //[I-S]LN=81;[I-E]
        cb.jump(); //[I-S]LN=82;[I-E]
 //[I-S]LN=83;[I-E]
        if (se != null) { //[I-S]LN=84;[I-E]
          se.prepareImmediate(); //[I-S]LN=85;[I-E]
        } //[I-S]LN=86;[I-E]
      } //[I-S]LN=87;[I-E]
    } //[I-S]LN=88;[I-E]
  } //[I-S]LN=89;[I-E]
 //[I-S]LN=90;[I-E]
  private void emitSteps() { //[I-S]LN=91;[I-E]
    if (walking) { //[I-S]LN=92;[I-E]
      getSE(); //[I-S]LN=93;[I-E]
      if (se != null) { //[I-S]LN=94;[I-E]
        if (cb.isGrounded()) { //[I-S]LN=95;[I-E]
          se.onWalk(walkVector.length(), cb, this); //[I-S]LN=96;[I-E]
        } //[I-S]LN=97;[I-E]
      } //[I-S]LN=98;[I-E]
    } //[I-S]LN=99;[I-E]
  } //[I-S]LN=100;[I-E]
 //[I-S]LN=101;[I-E]
  private void rotate() { //[I-S]LN=102;[I-E]
    Vector2 slide = ct.getSlideAxis(); //[I-S]LN=103;[I-E]
    if (slide == null) slide = zero; //[I-S]LN=104;[I-E]
 //[I-S]LN=105;[I-E]
    /// horizontal slide //[I-S]LN=106;[I-E]
    myObject.getTransform().rotateInSeconds(0, -slide.getX() * horizontalSensitivity * 360 * 0.0041f, 0); //[I-S]LN=107;[I-E]
 //[I-S]LN=108;[I-E]
    /// vertical slide //[I-S]LN=109;[I-E]
    getAC(); //[I-S]LN=110;[I-E]
    if (ac == null) { //[I-S]LN=111;[I-E]
      Terminal.log("AFPPCamera was not found..."); //[I-S]LN=112;[I-E]
      return; //[I-S]LN=113;[I-E]
    } //[I-S]LN=114;[I-E]
    ac.minAngle = cameraMinAngle; //[I-S]LN=115;[I-E]
    ac.maxAngle = cameraMaxAngle; //[I-S]LN=116;[I-E]
    ac.currentAngle += -slide.getY() * verticalSensitivity * 90 * 0.0008f; //[I-S]LN=117;[I-E]
    ac.set(); //[I-S]LN=118;[I-E]
  } //[I-S]LN=119;[I-E]
 //[I-S]LN=120;[I-E]
  private AFPPCamera getAC() { //[I-S]LN=121;[I-E]
    if (ac == null) { //[I-S]LN=122;[I-E]
      ac = myObject.findComponentInChildren(AFPPCamera.class); //[I-S]LN=123;[I-E]
    } //[I-S]LN=124;[I-E]
    return ac; //[I-S]LN=125;[I-E]
  } //[I-S]LN=126;[I-E]
 //[I-S]LN=127;[I-E]
  private Characterbody getCB() { //[I-S]LN=128;[I-E]
    if (cb == null) { //[I-S]LN=129;[I-E]
      cb = myObject.findComponent(Characterbody.class); //[I-S]LN=130;[I-E]
      if (cb == null) { //[I-S]LN=131;[I-E]
        print(this.getClass().getSimpleName() + " needs to be attached on a Characterbody object"); //[I-S]LN=132;[I-E]
      }  //[I-S]LN=133;[I-E]
    } //[I-S]LN=134;[I-E]
    return cb; //[I-S]LN=135;[I-E]
  } //[I-S]LN=136;[I-E]
 //[I-S]LN=137;[I-E]
  private IFPController getCT() { //[I-S]LN=138;[I-E]
    if (ct == null) { //[I-S]LN=139;[I-E]
      for (int x = 0; x < myObject.componentCount(); x++) { //[I-S]LN=140;[I-E]
        Component c = myObject.getComponentAt(x); //[I-S]LN=141;[I-E]
        if (c instanceof IFPController) { //[I-S]LN=142;[I-E]
          ct = (IFPController) c; //[I-S]LN=143;[I-E]
          break; //[I-S]LN=144;[I-E]
        } //[I-S]LN=145;[I-E]
      } //[I-S]LN=146;[I-E]
    } //[I-S]LN=147;[I-E]
    return ct; //[I-S]LN=148;[I-E]
  } //[I-S]LN=149;[I-E]
 //[I-S]LN=150;[I-E]
  private IFPStepsEmitter getSE() { //[I-S]LN=151;[I-E]
    if (se == null) { //[I-S]LN=152;[I-E]
      for (int x = 0; x < myObject.componentCount(); x++) { //[I-S]LN=153;[I-E]
        Component c = myObject.getComponentAt(x); //[I-S]LN=154;[I-E]
        if (c instanceof IFPStepsEmitter) { //[I-S]LN=155;[I-E]
          se = (IFPStepsEmitter) c; //[I-S]LN=156;[I-E]
          break; //[I-S]LN=157;[I-E]
        } //[I-S]LN=158;[I-E]
      } //[I-S]LN=159;[I-E]
    } //[I-S]LN=160;[I-E]
    return se; //[I-S]LN=161;[I-E]
  } //[I-S]LN=162;[I-E]
 //[I-S]LN=163;[I-E]
  /* Override */ //[I-S]LN=164;[I-E]
  public void addWaterTrigger(Component comp) { //[I-S]LN=165;[I-E]
    waterTriggers.add(comp); //[I-S]LN=166;[I-E]
  } //[I-S]LN=167;[I-E]
 //[I-S]LN=168;[I-E]
  /* Override */ //[I-S]LN=169;[I-E]
  public void removeWaterTrigger(Component comp) { //[I-S]LN=170;[I-E]
    waterTriggers.remove(comp); //[I-S]LN=171;[I-E]
  } //[I-S]LN=172;[I-E]
 //[I-S]LN=173;[I-E]
  /* Override */ //[I-S]LN=174;[I-E]
  public boolean isOnWater() { //[I-S]LN=175;[I-E]
    return !waterTriggers.isEmpty(); //[I-S]LN=176;[I-E]
  } //[I-S]LN=177;[I-E]
} //[I-S]LN=178;[I-E]